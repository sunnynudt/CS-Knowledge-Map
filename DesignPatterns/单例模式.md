### 单例模式

##### 1. 定义

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

##### 2. 实现单例模式

实现一个标准的单例模式，用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。

```js
const Singleton = function(name) {
    this.name = name
    this.instance = null
}

Singleton.prototype.getName = function() {
    alert(this.name)
}

Singleton.getInstance = function(name) {
    if (!this.instance) {
        this.instance = new Singleton(name)
    }

    return this.instance
}

const a = Singleton.getInstance('sven1')
const b = Singleton.getInstance('sven2')

alert(a === b) // true
```

通过 Signleton.getInstance 来获取 Singleton 类的唯一对象，这种方式相对简单，但是增加了这个类的‘不透明性’，跟以往通过 new XXX 的方式获取对象不同，Singleton 类的使用者必须得知道这是一个单例类，偏要使用 Single.getInstance 来获取对象。

所以，这段单例模式代码的意义不大。

##### 3. 透明的单例模式

一个‘透明’的单例类，用户从这个类中创建对象的时候，可以向像使用其他任何普通类一样。下面将使用 CreateDiv 单例类，作用是负责在页面中创建唯一的 div 节点。

```js
const CreateDiv = (function() {
    let instance

    const CreateDiv = function(html) {
        if (instance) {
            return instance
        }

        this.html = html
        this.init()

        return (instance = this)
    }

    CreateDiv.prototype.init = function() {
        const div = document.createElement('div')
        div.innerHTML = this.html
        document.body.appendChild(div)
    }

    return CreateDiv
})()

const a = new CreateDiv('sven1')
const b = new CreateDiv('sven2')

alert(a === b) // true
```

但是这个方法也有缺点，为了把 instance 封装起来，我们用了自执行的匿名函数和闭包，并且让这个匿名函数返回真正的 Singleton 构造方法，增加了一些程序的复杂度，阅读起来也不舒服。

##### 4. 用代理实现单例模式

```js
const CreateDiv = function(html) {
    this.html = html
    this.init()
}

CreateDiv.prototype.init = function() {
    const div = document.createElement('div')
    div.innerHTML = this.html
    document.body.appendChild(div)
}

const ProxySingletonCreateDiv = (function() {
    let instance

    return function(html) {
        if (!instance) {
            instance = new CreateDiv(html)
        }

        return instance
    }
})()

const a = new ProxySingletonCreateDiv('sven1')
const b = new ProxySingletonCreateDiv('sven2')

alert(a === b) // true
```

通过引入代理类的方式，实现了一个单例模式的编写，把负责管理单例的逻辑移到代理类 proxySingletonCreateDiv 中。这样，CreateDiv 就变成了一个普通的类，跟 proxySingletonCreateDiv 组合起来就可以达到单例模式的效果。
