# 从输入 URL 到页面展示，这中间发生了什么？

这个问题涉及到了网络、操作系统、Web 等一系列知识，下图是一个完整的流程示意图。

![](/Images/从输入URL到页面展示完整流程示意图.png)

如图，整个流程需要各个进程间的配合，分为两个步骤：导航流程和渲染流程。

## 1. 导航流程：用户发出 URL 请求到页面开始解析的过程

首先了解浏览器进程、渲染进程、网络进程的主要职责：

- 浏览器进程：主要负责用户交互、子进程管理和文件存储等功能。
- 网络进程：主要负责面向渲染进程和浏览器进程等提供网络下载功能。
- 渲染进程：主要职责是把从网络下载的 HTML、CSS、JS、图片等资源解析为可以显示和交互的页面。在 Chrome 中，渲染进程运行在安全沙箱里。

### 1 用户输入

如果搜索内容，地址栏会使用默认的搜索引擎，合成新的带搜索关键字的 URL。如果输入内容符合 URL 规则，地址栏会根据规则加上协议等，合成完整的 URL。

### 2. URL 请求过程

*浏览器进程*通过*进程间通信*（IPC）把 URL 请求发送至网络进程，*网络进程*接收后，发起 URL 请求流程。

1. 首先，网络进程每次发起请求时，都会先在浏览器缓存中查询该请求结果和缓存标识。

   - [浏览器缓存机制](/Issues/浏览器缓存机制.md)

2. 网络请求流程

   - [DNS 域名解析](/Issues/DNS域名解析.md)：获取请求域名的服务器 IP 地址。
   - TCP/IP: 利用 IP 和服务器建立 TCP 连接。

     - 建立连接：是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。
     - [TCP 三次握手](/Issues/TCP三次握手.md)
     - [TCP 四次挥手](/Issues/TCP四次挥手.md)
     - TCP 状态机：图中加粗加黑的部分是上述主要流程，其中阿拉伯数字的序号是连接过程中的顺序，大写中文数字的序号是连接断开过程中的顺序，加粗的实线是客户端 A 的状态变迁，加粗的虚线是服务端 B 的状态变迁。
       ![](/Images/TCP状态机.jpg)

- HTTP/HTTPS: 建立 TCP 连接后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。
  - [HTTPS 工作模式](/Issues/HTTPS请求流程.md)
    ![](/Images/HTTPS请求流程.png)
- 服务器接收请求信息后，生成响应数据，并发给网络进程。网络进程接收到并解析响应头信息。
  - 重定向：如果返回的状态码是 301 或 302，网络进程会从响应头的`Location`字段读取重定向的地址，重新发起 HTTP（HTTPS）请求，一切从头开始。
  - `HSTS`(HTTP 严格传输协议，HTTP Strict Transport Security)
    - HTTPS 服务器可以在响应头里添加一个`Strict-Transport-Security`字段，再设置一个有效期 A，告诉浏览器本网站只能使用 HTTPS，在 A 时间内都不允许使用 HTTP。
    - 浏览器如果再访问同样域名，就会自动把 URL 里的 HTTP 改成 HTTPS 直接访问网站，减少了一次跳转，加快了连接速度，也避免了“中间人攻击”。这样，浏览器只会在第一次连接使用 HTTP，之后都会走 HTTPS。
  - 响应类型数据处理：`Content-type`字段，如果字段值为`octet-stream`等值被浏览器判断为*下载类型*，那么该请求就会被提交给浏览器的*下载管理器*，同时该 URL 的导航流程就此结束。如果字段值为`HTML`等，浏览器继续进行导航流程。

### 3. 准备渲染进程

打开一个新页面采用的渲染进程策略（以 Chrome）为例：

- 通常情况下，打开新的页面都会使用一个单独的渲染进程。
- 如果是从 A 页面打开 B 页面，且 A 和 B 都属于同一站点，那么 B 页面会复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。
- 渲染进程准备好后，此时的文档数据还在网络进程中，并没有提交给渲染进程。

### 4. 提交文档

*文档*是指 URL 请求的响应体数据。

- “提交文档”的消息由浏览器进程发出，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。
- 等文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程。
- 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，并更新 Web 页面。

### 5. 渲染阶段

一旦文档被提交，渲染进程便开始页面解析和子资源加载。一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。

## 2. 渲染流程

![](/Images/完整的渲染流水线示意图.png)

### 1. 构建 DOM 树：将 HTML 转为浏览器能读懂的 DOM 树结构

### 2. 样式计算（Recalculate Style），计算出 DOM 节点的样式

1. 把 CSS 转换为浏览器能够理解的结构-styleSheets。CSS 样式来源主要有 3 种：
   - 通过 link 引用的外部 CSS 文件
   - `<style>`标记内的 CSS
   - 元素的 style 属性内嵌的 CSS
2. 转换样式表中的属性值，使其标准化。比如：
   - `font-size: 2em; => font-size: 32px;`
   - `color: blue; => color: rgb(0, 0, 255);`
   - `font-weight: bold; => font-weight: 700;`
3. 计算出 DOM 树中每个节点的具体样式。
   - CSS 的继承和层叠规则

### 3. 布局阶段：计算元素的布局信息

有 DOM 树和 DOM 树中元素的样式，不足以显示页面，因为还不知道 DOM 元素的几何位置信息。

1. 创建布局树
   - 遍历 DOM 树中的所有可见节点，并将这些节点加到布局中
   - 不可见的节点会被布局树忽略，比如`head`、`script`等标签下面的全部内容和属性为`display: none;`节点
2. 布局计算

### 4. 分层：对布局树进行分层，生成分层树

因为页面中有很多复杂的效果，比如 3D 变换、页面滚动或者使用 `z-index` 做 z 轴排序等，为了更加方便的实现这些效果，渲染引擎还需要为特定节点生成专用的图层，并生成一颗对应的图层树(LayerTree)。

通常，并不是布局树的每一个节点都包含一个图层，如果一个节点没有对应的层，那么就从属于父节点的图层。

- 拥有层叠上下文属性的元素会被提升为单独的一层。比如明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等。
- 需要裁剪(clip)的地方也会被创建为图层。

### 5. 图层绘制：为每个图层生成绘制列表，将其提交到合成线程

### 6. 栅格化(raster)操作：合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成。当图层的绘制列表准备好后，主线程就会把该绘制列表提交(commit)给合成线程。

- 合成线程会将图层划分为图块 tile
- 合成线程会按照视口附件的图块来优先生成位图，实际生成位图的操作由栅格化来执行。栅格化，就是指将图块转换为位图

### 7.合成和显示：合成线程发送绘制图块命令 DrawQuad 给*浏览器进程*，浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上

- 一旦所有图块都被栅格化，合成线程就会生成一个绘制图块命令——"DrawQuad"，然后将该命令提交给*浏览器进程*。
- 浏览器进程有一个叫`viz`的组件，用来接收合成线程发过来的"DrawQuad"命令，然后根据该命令，将其页面内容绘制到*内存*中，最后再将内存显示在屏幕上。

## 3. 相关问题

1. 现在浏览器与服务器建立了 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？

   - 短连接
     - HTTP/1.0 协议采用“请求-应答”方式，底层的数据传输基于 TCP/IP，每次发送请求前需先与服务器建立连接，收到响应报文后会立即关闭连接。整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以称为短连接（short-lived-connections）。
     - TCP 协议建立连接需要三次握手，断开连接需要四次挥手，耗时较久，代价过大。
     - 短连接的缺点严重制约了服务器的服务能力，导致它无法处理更多的请求。
   - 长连接
     - HTTP/1.1 中连接默认启用长连接，不需要使用特殊字段指定，只要向服务器发送了第一次请求，后续的请求都会复用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。
     - 也可以在请求头中明确的要求使用长连接机制，`Connection: keep-alive`。
     - 不管客户端是否显式的要求长连接，如果服务器支持长连接，它总会在响应报文里放一个`Connection: keep-alive`字段，告诉客户端自己支持长连接，接下来就用这个 TCP 一直收发数据吧。
     - 缺点：TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，会占用服务器的资源。
     - 关闭长连接
       - 客户端：在请求头里添加“Connection: close”。
       - 服务端：通常不会主动关闭长连接，但是会采用一些策略，以 Nginx 为例。
         - 使用“keepalive_timeout”指令，设置长连接的*超时时间*。如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。
         - 使用“keepalive_requests”指令，设置长连接上*可发送的最大请求次数*，比如设置成 1000，如果这个连接上处理了 1000 个请求后，也会主动断开连接。

2. 一个 TCP 连接中 HTTP 请求可以一起发送吗？比如一起发送三个请求，再三个响应一起发送？

   - HTTP/1.1 中，单个 TCP 连接在同一时刻只能处理一个请求，即 2 个请求的生命周期不能重叠，任意 2 个 HTTP 请求从开始到结束的时间在同一个 TCP 连接中不能重叠。
     - 在 HTTP/1.1，浏览器提高页面加载效率的方法：
       - 长连接
       - 和服务器建立多个 TCP 连接
   - HTTP/2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。

3. 浏览器对同一 Host 建立 TCP 连接数量有没有限制？

   - Chrome 允许对同一个 host 最多建立 6 个 TCP 连接。

4. 如果下载 CSS 文件阻塞了，会阻塞 DOM 树的合成吗？会阻塞页面的显示吗？

   - 当从服务器接收 HTML 页面的第一批数据，DOM 解析器就开始工作了，在解析过程中，如果遇到 JS 脚本（假设是内联），那么 DOM 解析器会先执行 JS 脚本，执行完成后，再继续往下解析。
   - 如果 JS 脚本是外部文件，`<script src="foo.js"></script>`形式，会下载脚本文件，然后执行该脚本，然后再继续往下解析 DOM。所以**JS 文件会阻塞 DOM 渲染**。
   - 当在 JS 中访问了某个元素的样式，那么就需要等待这个样式被下载完成才能继续往下执行，所以这种情况下**CSS 也会阻塞 DOM 的解析**。
   - 所以 JS 和 CSS 都有可能会阻塞 DOM 解析。

5. [三个和渲染流程有关的概念：重排、重绘、合成，如何减少重排重绘，优化 web 性能？](/Issues/重排重绘合成.md)

6. 分层、合成机制：CSS 动画为什么比 JS 高效？

> Q: 既然 css 动画会跳过重绘阶段，则意味着合成阶段的绘制列表不会变化。但是最终得到的相邻两帧的位图是不一样的。那么在合成阶段，相同的绘制列表是如何绘制出不同的位图的？难道绘制列表是有状态的？还是绘制列表一次能绘制出多张位图？

> A: 记住一点，能直接在合成线程中完成的任务都*不会*改变图层的内容，如文字信息、布局、颜色的改变，统统不会涉及，涉及到这些内容就会牵涉到重排和重绘了。能直接在合成线程中实现的是整个图层的几个变换、透明度变换、阴影等，这些变化都不会影响到图层的内容。比如滚动页面的时候，整个页面内容没有变化，这个时候其实是对图层做上下移动，这种操作直接在合成线程里面就可以完成了。

## 4. 参考文献

- [一文读懂一个 URL 请求的过程是怎样的](https://juejin.im/post/5b83b0bfe51d4538c63131a8)

- [Github: 深入理解浏览器的缓存机制](https://github.com/ljianshu/Blog/issues/23)

- [Github: 当···时发生了什么？](https://github.com/skyline75489/what-happens-when-zh_CN)

- [Github: 从浏览器输入一个 url 到页面渲染，涉及的知识点及优化点](https://github.com/sunyongjian/blog/issues/34)

- [Github: 从 URL 输入到页面展现到底发生什么？](https://github.com/ljianshu/Blog/issues/24)

- [前端经典面试题: 从输入 URL 到页面加载发生了什么？](https://segmentfault.com/a/1190000006879700)

- [可能是全网最全的 http 面试答案](https://juejin.im/post/5d032b77e51d45777a126183)

- [前端基础篇之 HTTP 协议](https://juejin.im/post/5cd0438c6fb9a031ec6d3ab2)

- [Github: 深入浅出浏览器渲染原理](https://github.com/ljianshu/Blog/issues/51)

- [Github: 浏览器存储](https://github.com/ljianshu/Blog/issues/25)

- [知乎：一文读懂前端缓存](https://zhuanlan.zhihu.com/p/44789005)

- [知乎：你猜一个 TCP 连接上面能发多少个 HTTP 请求](https://zhuanlan.zhihu.com/p/61423830)
