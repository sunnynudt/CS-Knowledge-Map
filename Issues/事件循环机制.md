事件循环不仅仅包含事件队列，而是具有至少 2 个队列，除了事件，还要保持浏览器执行的其他操作。这些操作称为任务，且分为 2 大类：宏任务（通常称为任务）和微任务。

- 宏任务

  - 比如创建文档对象、解析 HTML、执行主线（全局）JS 代码，更改当前 URL 以及各种事件，如页面加载、输入、网络事件和定时器事件。
  - 从浏览器角度看，宏任务代表一个个离散的、独立工作单元。运行完任务后，浏览器可以继续其他调度，如重新渲染页面的 UI 或执行垃圾回收。

- 微任务

  - 更小的任务。微任务更新应用程序的状态，但*必须*在浏览器任务继续执行其他任务*之前*执行，浏览器任务包括重新渲染页面 UI。
  - 微任务包括：Promise 回调函数、DOM 发生变化等。
  - 微任务需要尽可能快地、通过异步方式执行，同时*不能*产生全新的微任务。
  - 微任务使得我们能够在重新渲染 UI 之前执行指定的行为，避免不必要的 UI 重绘，UI 重绘使应用程序的状态不连续。

事件循环基于两个基本原则：

- 一次处理一个任务。
- 一个任务开始后直到运行完成，不会被其他任务中断。

处理宏任务和微任务的区别：_单次循环迭代中，最多处理一个宏任务（其余的在队列中等待），而队列中的所有微任务都会被处理_。

![](/Images/事件循环机制_忍者秘籍.png)

- 两类任务队列都是独立于事件循环的，这意味着任务队列的添加行为也发生在事件循环外。如何不这样设计，则会导致在执行 JS 代码时，发生任何事件都将被忽略。
- 因为 JS 是基于单线程执行模型，所以这两类任务都是逐个执行的。当一个任务开始执行后，在完成前，中间不会被任何其他任务中断。除非浏览器决定中止执行该任务，例如某个任务执行过久或占用内存过大。
- 所有的微任务会在下一次渲染前执行完成，因为它的目标是在渲染前更新应用程序状态。
- 理想情况下，单个任务和该任务附属的所有微任务，都应在 16ms 内完成（60fps，浏览器 16ms 内渲染一帧）。
