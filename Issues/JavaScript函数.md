### 理解函数调用

1. 当调用函数时，除了传入在函数定义中显式声明的参数之外，同时还传入 2 个隐式参数：`arguments`与`this`。

   - `arguments`参数是传入函数的所有参数的集合。具有`length`属性，表示传入参数的个数，通过`arguments`参数还可获取那些与函数形参不匹配的参数。在非严格模式下，`arguments`对象是函数参数的别名，修改`arguments`对象会修改参数实参，可以通过严格模式避免修改函数实参。
   - `this`表示函数上下文，即与函数调用相关联的对象。函数的定义方式和调用方式决定了`this`的取值。

2. 函数调用的 4 种方式：

   - 作为函数调用：`fn()`;
   - 作为方法调用：`obj.fn()`;
   - 作为构造函数调用：`new fn()`;
   - 通过`apply`和`call`方法调用：`fn.apply(obj)`或`fn.call(obj)`。

3. 函数的调用方式影响`this`的取值

   - 如果作为函数调用，在非严格模式下，`this`指向全局`window`对象；在严格模式下，`this`指向`undefined`。
   - 作为方法调用，`this`通常指向调用的对象。
   - 作为构造函数调用，`this`指向新创建的对象。
   - 通过`call`或`apply`调用，`this`指向`call`或`apply`的第一个参数。

4. 箭头函数没有单独的`this`值，`this`在箭头函数创建时确定。

   - 箭头函数自身不含上下文，从定义时的所在函数继承上下文。
   - 调用箭头函数时，不会隐式传入`this`参数，而是从定义时的函数继承上下文。

5. 所有函数均可使用`bind`方法，创建新函数，并绑定到`bind`方法传入的参数上，被绑定的函数与原始函数具有一致的行为。
6. 使用`new`调用函数时：
   - 创建一个*新*的*空对象*；
   - 该对象作为`this`参数传递给构造函数，从而成为构造函数的`函数上下文`;
   - 新构造的对象作为`new`运算符的返回值（也有其他情况，如下所示）。
     - 如果构造函数返回一个对象，则该对象将作为整个表达式的值返回，而传入构造函数的`this`将被丢弃；
     - 但是，如果构造函数返回的是非对象类型，则忽略返回值，返回新创建的对象。

### 闭包和作用域

1. 通过闭包可以访问创建闭包时所处环境中的全部变量。闭包为函数创建时所处的作用域中的函数和变量，创建“安全气泡”。通过这种方式，即使创建函数时所处的作用域已经消失，但是函数仍然能够获得执行时所需的全部内容。

2. 可以使用闭包实现下述高级功能：

   - 通过构造函数内的变量以及构造方法来模拟对象的私有属性。
   - 处理回调函数，简化代码。

3. `JavaScript`引擎通过*执行上下文栈*(调用栈)跟踪函数的执行。每次调用函数时，都会创建*新*的*函数执行上下文*，并推入调用栈顶端。当函数执行完成后，对应的执行上下文将从调用栈中推出。
4. `JavaScript`引擎通过词法环境跟踪标识符（俗称作用域）。
5. 闭包是 js 作用域规则的副作用。当函数创建时所在的作用域消失后，仍然能够调用函数。
